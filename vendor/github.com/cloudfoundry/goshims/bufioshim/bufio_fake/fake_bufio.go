// Code generated by counterfeiter. DO NOT EDIT.
package bufio_fake

import (
	"bufio"
	"io"
	"sync"

	"code.cloudfoundry.org/goshims/bufioshim"
)

type FakeBufio struct {
	NewReadWriterStub        func(*bufio.Reader, *bufio.Writer) *bufio.ReadWriter
	newReadWriterMutex       sync.RWMutex
	newReadWriterArgsForCall []struct {
		arg1 *bufio.Reader
		arg2 *bufio.Writer
	}
	newReadWriterReturns struct {
		result1 *bufio.ReadWriter
	}
	newReadWriterReturnsOnCall map[int]struct {
		result1 *bufio.ReadWriter
	}
	NewReaderStub        func(io.Reader) bufioshim.Reader
	newReaderMutex       sync.RWMutex
	newReaderArgsForCall []struct {
		arg1 io.Reader
	}
	newReaderReturns struct {
		result1 bufioshim.Reader
	}
	newReaderReturnsOnCall map[int]struct {
		result1 bufioshim.Reader
	}
	NewReaderSizeStub        func(io.Reader, int) bufioshim.Reader
	newReaderSizeMutex       sync.RWMutex
	newReaderSizeArgsForCall []struct {
		arg1 io.Reader
		arg2 int
	}
	newReaderSizeReturns struct {
		result1 bufioshim.Reader
	}
	newReaderSizeReturnsOnCall map[int]struct {
		result1 bufioshim.Reader
	}
	NewScannerStub        func(io.Reader) *bufio.Scanner
	newScannerMutex       sync.RWMutex
	newScannerArgsForCall []struct {
		arg1 io.Reader
	}
	newScannerReturns struct {
		result1 *bufio.Scanner
	}
	newScannerReturnsOnCall map[int]struct {
		result1 *bufio.Scanner
	}
	NewWriterStub        func(io.Writer) *bufio.Writer
	newWriterMutex       sync.RWMutex
	newWriterArgsForCall []struct {
		arg1 io.Writer
	}
	newWriterReturns struct {
		result1 *bufio.Writer
	}
	newWriterReturnsOnCall map[int]struct {
		result1 *bufio.Writer
	}
	NewWriterSizeStub        func(io.Writer, int) *bufio.Writer
	newWriterSizeMutex       sync.RWMutex
	newWriterSizeArgsForCall []struct {
		arg1 io.Writer
		arg2 int
	}
	newWriterSizeReturns struct {
		result1 *bufio.Writer
	}
	newWriterSizeReturnsOnCall map[int]struct {
		result1 *bufio.Writer
	}
	ScanBytesStub        func([]byte, bool) (int, []byte, error)
	scanBytesMutex       sync.RWMutex
	scanBytesArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	scanBytesReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	scanBytesReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	ScanLinesStub        func([]byte, bool) (int, []byte, error)
	scanLinesMutex       sync.RWMutex
	scanLinesArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	scanLinesReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	scanLinesReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	ScanRunesStub        func([]byte, bool) (int, []byte, error)
	scanRunesMutex       sync.RWMutex
	scanRunesArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	scanRunesReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	scanRunesReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	ScanWordsStub        func([]byte, bool) (int, []byte, error)
	scanWordsMutex       sync.RWMutex
	scanWordsArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	scanWordsReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	scanWordsReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBufio) NewReadWriter(arg1 *bufio.Reader, arg2 *bufio.Writer) *bufio.ReadWriter {
	fake.newReadWriterMutex.Lock()
	ret, specificReturn := fake.newReadWriterReturnsOnCall[len(fake.newReadWriterArgsForCall)]
	fake.newReadWriterArgsForCall = append(fake.newReadWriterArgsForCall, struct {
		arg1 *bufio.Reader
		arg2 *bufio.Writer
	}{arg1, arg2})
	fake.recordInvocation("NewReadWriter", []interface{}{arg1, arg2})
	fake.newReadWriterMutex.Unlock()
	if fake.NewReadWriterStub != nil {
		return fake.NewReadWriterStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newReadWriterReturns
	return fakeReturns.result1
}

func (fake *FakeBufio) NewReadWriterCallCount() int {
	fake.newReadWriterMutex.RLock()
	defer fake.newReadWriterMutex.RUnlock()
	return len(fake.newReadWriterArgsForCall)
}

func (fake *FakeBufio) NewReadWriterCalls(stub func(*bufio.Reader, *bufio.Writer) *bufio.ReadWriter) {
	fake.newReadWriterMutex.Lock()
	defer fake.newReadWriterMutex.Unlock()
	fake.NewReadWriterStub = stub
}

func (fake *FakeBufio) NewReadWriterArgsForCall(i int) (*bufio.Reader, *bufio.Writer) {
	fake.newReadWriterMutex.RLock()
	defer fake.newReadWriterMutex.RUnlock()
	argsForCall := fake.newReadWriterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) NewReadWriterReturns(result1 *bufio.ReadWriter) {
	fake.newReadWriterMutex.Lock()
	defer fake.newReadWriterMutex.Unlock()
	fake.NewReadWriterStub = nil
	fake.newReadWriterReturns = struct {
		result1 *bufio.ReadWriter
	}{result1}
}

func (fake *FakeBufio) NewReadWriterReturnsOnCall(i int, result1 *bufio.ReadWriter) {
	fake.newReadWriterMutex.Lock()
	defer fake.newReadWriterMutex.Unlock()
	fake.NewReadWriterStub = nil
	if fake.newReadWriterReturnsOnCall == nil {
		fake.newReadWriterReturnsOnCall = make(map[int]struct {
			result1 *bufio.ReadWriter
		})
	}
	fake.newReadWriterReturnsOnCall[i] = struct {
		result1 *bufio.ReadWriter
	}{result1}
}

func (fake *FakeBufio) NewReader(arg1 io.Reader) bufioshim.Reader {
	fake.newReaderMutex.Lock()
	ret, specificReturn := fake.newReaderReturnsOnCall[len(fake.newReaderArgsForCall)]
	fake.newReaderArgsForCall = append(fake.newReaderArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	fake.recordInvocation("NewReader", []interface{}{arg1})
	fake.newReaderMutex.Unlock()
	if fake.NewReaderStub != nil {
		return fake.NewReaderStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newReaderReturns
	return fakeReturns.result1
}

func (fake *FakeBufio) NewReaderCallCount() int {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	return len(fake.newReaderArgsForCall)
}

func (fake *FakeBufio) NewReaderCalls(stub func(io.Reader) bufioshim.Reader) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = stub
}

func (fake *FakeBufio) NewReaderArgsForCall(i int) io.Reader {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	argsForCall := fake.newReaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBufio) NewReaderReturns(result1 bufioshim.Reader) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = nil
	fake.newReaderReturns = struct {
		result1 bufioshim.Reader
	}{result1}
}

func (fake *FakeBufio) NewReaderReturnsOnCall(i int, result1 bufioshim.Reader) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = nil
	if fake.newReaderReturnsOnCall == nil {
		fake.newReaderReturnsOnCall = make(map[int]struct {
			result1 bufioshim.Reader
		})
	}
	fake.newReaderReturnsOnCall[i] = struct {
		result1 bufioshim.Reader
	}{result1}
}

func (fake *FakeBufio) NewReaderSize(arg1 io.Reader, arg2 int) bufioshim.Reader {
	fake.newReaderSizeMutex.Lock()
	ret, specificReturn := fake.newReaderSizeReturnsOnCall[len(fake.newReaderSizeArgsForCall)]
	fake.newReaderSizeArgsForCall = append(fake.newReaderSizeArgsForCall, struct {
		arg1 io.Reader
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("NewReaderSize", []interface{}{arg1, arg2})
	fake.newReaderSizeMutex.Unlock()
	if fake.NewReaderSizeStub != nil {
		return fake.NewReaderSizeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newReaderSizeReturns
	return fakeReturns.result1
}

func (fake *FakeBufio) NewReaderSizeCallCount() int {
	fake.newReaderSizeMutex.RLock()
	defer fake.newReaderSizeMutex.RUnlock()
	return len(fake.newReaderSizeArgsForCall)
}

func (fake *FakeBufio) NewReaderSizeCalls(stub func(io.Reader, int) bufioshim.Reader) {
	fake.newReaderSizeMutex.Lock()
	defer fake.newReaderSizeMutex.Unlock()
	fake.NewReaderSizeStub = stub
}

func (fake *FakeBufio) NewReaderSizeArgsForCall(i int) (io.Reader, int) {
	fake.newReaderSizeMutex.RLock()
	defer fake.newReaderSizeMutex.RUnlock()
	argsForCall := fake.newReaderSizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) NewReaderSizeReturns(result1 bufioshim.Reader) {
	fake.newReaderSizeMutex.Lock()
	defer fake.newReaderSizeMutex.Unlock()
	fake.NewReaderSizeStub = nil
	fake.newReaderSizeReturns = struct {
		result1 bufioshim.Reader
	}{result1}
}

func (fake *FakeBufio) NewReaderSizeReturnsOnCall(i int, result1 bufioshim.Reader) {
	fake.newReaderSizeMutex.Lock()
	defer fake.newReaderSizeMutex.Unlock()
	fake.NewReaderSizeStub = nil
	if fake.newReaderSizeReturnsOnCall == nil {
		fake.newReaderSizeReturnsOnCall = make(map[int]struct {
			result1 bufioshim.Reader
		})
	}
	fake.newReaderSizeReturnsOnCall[i] = struct {
		result1 bufioshim.Reader
	}{result1}
}

func (fake *FakeBufio) NewScanner(arg1 io.Reader) *bufio.Scanner {
	fake.newScannerMutex.Lock()
	ret, specificReturn := fake.newScannerReturnsOnCall[len(fake.newScannerArgsForCall)]
	fake.newScannerArgsForCall = append(fake.newScannerArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	fake.recordInvocation("NewScanner", []interface{}{arg1})
	fake.newScannerMutex.Unlock()
	if fake.NewScannerStub != nil {
		return fake.NewScannerStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newScannerReturns
	return fakeReturns.result1
}

func (fake *FakeBufio) NewScannerCallCount() int {
	fake.newScannerMutex.RLock()
	defer fake.newScannerMutex.RUnlock()
	return len(fake.newScannerArgsForCall)
}

func (fake *FakeBufio) NewScannerCalls(stub func(io.Reader) *bufio.Scanner) {
	fake.newScannerMutex.Lock()
	defer fake.newScannerMutex.Unlock()
	fake.NewScannerStub = stub
}

func (fake *FakeBufio) NewScannerArgsForCall(i int) io.Reader {
	fake.newScannerMutex.RLock()
	defer fake.newScannerMutex.RUnlock()
	argsForCall := fake.newScannerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBufio) NewScannerReturns(result1 *bufio.Scanner) {
	fake.newScannerMutex.Lock()
	defer fake.newScannerMutex.Unlock()
	fake.NewScannerStub = nil
	fake.newScannerReturns = struct {
		result1 *bufio.Scanner
	}{result1}
}

func (fake *FakeBufio) NewScannerReturnsOnCall(i int, result1 *bufio.Scanner) {
	fake.newScannerMutex.Lock()
	defer fake.newScannerMutex.Unlock()
	fake.NewScannerStub = nil
	if fake.newScannerReturnsOnCall == nil {
		fake.newScannerReturnsOnCall = make(map[int]struct {
			result1 *bufio.Scanner
		})
	}
	fake.newScannerReturnsOnCall[i] = struct {
		result1 *bufio.Scanner
	}{result1}
}

func (fake *FakeBufio) NewWriter(arg1 io.Writer) *bufio.Writer {
	fake.newWriterMutex.Lock()
	ret, specificReturn := fake.newWriterReturnsOnCall[len(fake.newWriterArgsForCall)]
	fake.newWriterArgsForCall = append(fake.newWriterArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.recordInvocation("NewWriter", []interface{}{arg1})
	fake.newWriterMutex.Unlock()
	if fake.NewWriterStub != nil {
		return fake.NewWriterStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newWriterReturns
	return fakeReturns.result1
}

func (fake *FakeBufio) NewWriterCallCount() int {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	return len(fake.newWriterArgsForCall)
}

func (fake *FakeBufio) NewWriterCalls(stub func(io.Writer) *bufio.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = stub
}

func (fake *FakeBufio) NewWriterArgsForCall(i int) io.Writer {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	argsForCall := fake.newWriterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBufio) NewWriterReturns(result1 *bufio.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = nil
	fake.newWriterReturns = struct {
		result1 *bufio.Writer
	}{result1}
}

func (fake *FakeBufio) NewWriterReturnsOnCall(i int, result1 *bufio.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = nil
	if fake.newWriterReturnsOnCall == nil {
		fake.newWriterReturnsOnCall = make(map[int]struct {
			result1 *bufio.Writer
		})
	}
	fake.newWriterReturnsOnCall[i] = struct {
		result1 *bufio.Writer
	}{result1}
}

func (fake *FakeBufio) NewWriterSize(arg1 io.Writer, arg2 int) *bufio.Writer {
	fake.newWriterSizeMutex.Lock()
	ret, specificReturn := fake.newWriterSizeReturnsOnCall[len(fake.newWriterSizeArgsForCall)]
	fake.newWriterSizeArgsForCall = append(fake.newWriterSizeArgsForCall, struct {
		arg1 io.Writer
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("NewWriterSize", []interface{}{arg1, arg2})
	fake.newWriterSizeMutex.Unlock()
	if fake.NewWriterSizeStub != nil {
		return fake.NewWriterSizeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newWriterSizeReturns
	return fakeReturns.result1
}

func (fake *FakeBufio) NewWriterSizeCallCount() int {
	fake.newWriterSizeMutex.RLock()
	defer fake.newWriterSizeMutex.RUnlock()
	return len(fake.newWriterSizeArgsForCall)
}

func (fake *FakeBufio) NewWriterSizeCalls(stub func(io.Writer, int) *bufio.Writer) {
	fake.newWriterSizeMutex.Lock()
	defer fake.newWriterSizeMutex.Unlock()
	fake.NewWriterSizeStub = stub
}

func (fake *FakeBufio) NewWriterSizeArgsForCall(i int) (io.Writer, int) {
	fake.newWriterSizeMutex.RLock()
	defer fake.newWriterSizeMutex.RUnlock()
	argsForCall := fake.newWriterSizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) NewWriterSizeReturns(result1 *bufio.Writer) {
	fake.newWriterSizeMutex.Lock()
	defer fake.newWriterSizeMutex.Unlock()
	fake.NewWriterSizeStub = nil
	fake.newWriterSizeReturns = struct {
		result1 *bufio.Writer
	}{result1}
}

func (fake *FakeBufio) NewWriterSizeReturnsOnCall(i int, result1 *bufio.Writer) {
	fake.newWriterSizeMutex.Lock()
	defer fake.newWriterSizeMutex.Unlock()
	fake.NewWriterSizeStub = nil
	if fake.newWriterSizeReturnsOnCall == nil {
		fake.newWriterSizeReturnsOnCall = make(map[int]struct {
			result1 *bufio.Writer
		})
	}
	fake.newWriterSizeReturnsOnCall[i] = struct {
		result1 *bufio.Writer
	}{result1}
}

func (fake *FakeBufio) ScanBytes(arg1 []byte, arg2 bool) (int, []byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.scanBytesMutex.Lock()
	ret, specificReturn := fake.scanBytesReturnsOnCall[len(fake.scanBytesArgsForCall)]
	fake.scanBytesArgsForCall = append(fake.scanBytesArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	fake.recordInvocation("ScanBytes", []interface{}{arg1Copy, arg2})
	fake.scanBytesMutex.Unlock()
	if fake.ScanBytesStub != nil {
		return fake.ScanBytesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.scanBytesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBufio) ScanBytesCallCount() int {
	fake.scanBytesMutex.RLock()
	defer fake.scanBytesMutex.RUnlock()
	return len(fake.scanBytesArgsForCall)
}

func (fake *FakeBufio) ScanBytesCalls(stub func([]byte, bool) (int, []byte, error)) {
	fake.scanBytesMutex.Lock()
	defer fake.scanBytesMutex.Unlock()
	fake.ScanBytesStub = stub
}

func (fake *FakeBufio) ScanBytesArgsForCall(i int) ([]byte, bool) {
	fake.scanBytesMutex.RLock()
	defer fake.scanBytesMutex.RUnlock()
	argsForCall := fake.scanBytesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) ScanBytesReturns(result1 int, result2 []byte, result3 error) {
	fake.scanBytesMutex.Lock()
	defer fake.scanBytesMutex.Unlock()
	fake.ScanBytesStub = nil
	fake.scanBytesReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanBytesReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.scanBytesMutex.Lock()
	defer fake.scanBytesMutex.Unlock()
	fake.ScanBytesStub = nil
	if fake.scanBytesReturnsOnCall == nil {
		fake.scanBytesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.scanBytesReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanLines(arg1 []byte, arg2 bool) (int, []byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.scanLinesMutex.Lock()
	ret, specificReturn := fake.scanLinesReturnsOnCall[len(fake.scanLinesArgsForCall)]
	fake.scanLinesArgsForCall = append(fake.scanLinesArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	fake.recordInvocation("ScanLines", []interface{}{arg1Copy, arg2})
	fake.scanLinesMutex.Unlock()
	if fake.ScanLinesStub != nil {
		return fake.ScanLinesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.scanLinesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBufio) ScanLinesCallCount() int {
	fake.scanLinesMutex.RLock()
	defer fake.scanLinesMutex.RUnlock()
	return len(fake.scanLinesArgsForCall)
}

func (fake *FakeBufio) ScanLinesCalls(stub func([]byte, bool) (int, []byte, error)) {
	fake.scanLinesMutex.Lock()
	defer fake.scanLinesMutex.Unlock()
	fake.ScanLinesStub = stub
}

func (fake *FakeBufio) ScanLinesArgsForCall(i int) ([]byte, bool) {
	fake.scanLinesMutex.RLock()
	defer fake.scanLinesMutex.RUnlock()
	argsForCall := fake.scanLinesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) ScanLinesReturns(result1 int, result2 []byte, result3 error) {
	fake.scanLinesMutex.Lock()
	defer fake.scanLinesMutex.Unlock()
	fake.ScanLinesStub = nil
	fake.scanLinesReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanLinesReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.scanLinesMutex.Lock()
	defer fake.scanLinesMutex.Unlock()
	fake.ScanLinesStub = nil
	if fake.scanLinesReturnsOnCall == nil {
		fake.scanLinesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.scanLinesReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanRunes(arg1 []byte, arg2 bool) (int, []byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.scanRunesMutex.Lock()
	ret, specificReturn := fake.scanRunesReturnsOnCall[len(fake.scanRunesArgsForCall)]
	fake.scanRunesArgsForCall = append(fake.scanRunesArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	fake.recordInvocation("ScanRunes", []interface{}{arg1Copy, arg2})
	fake.scanRunesMutex.Unlock()
	if fake.ScanRunesStub != nil {
		return fake.ScanRunesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.scanRunesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBufio) ScanRunesCallCount() int {
	fake.scanRunesMutex.RLock()
	defer fake.scanRunesMutex.RUnlock()
	return len(fake.scanRunesArgsForCall)
}

func (fake *FakeBufio) ScanRunesCalls(stub func([]byte, bool) (int, []byte, error)) {
	fake.scanRunesMutex.Lock()
	defer fake.scanRunesMutex.Unlock()
	fake.ScanRunesStub = stub
}

func (fake *FakeBufio) ScanRunesArgsForCall(i int) ([]byte, bool) {
	fake.scanRunesMutex.RLock()
	defer fake.scanRunesMutex.RUnlock()
	argsForCall := fake.scanRunesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) ScanRunesReturns(result1 int, result2 []byte, result3 error) {
	fake.scanRunesMutex.Lock()
	defer fake.scanRunesMutex.Unlock()
	fake.ScanRunesStub = nil
	fake.scanRunesReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanRunesReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.scanRunesMutex.Lock()
	defer fake.scanRunesMutex.Unlock()
	fake.ScanRunesStub = nil
	if fake.scanRunesReturnsOnCall == nil {
		fake.scanRunesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.scanRunesReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanWords(arg1 []byte, arg2 bool) (int, []byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.scanWordsMutex.Lock()
	ret, specificReturn := fake.scanWordsReturnsOnCall[len(fake.scanWordsArgsForCall)]
	fake.scanWordsArgsForCall = append(fake.scanWordsArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	fake.recordInvocation("ScanWords", []interface{}{arg1Copy, arg2})
	fake.scanWordsMutex.Unlock()
	if fake.ScanWordsStub != nil {
		return fake.ScanWordsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.scanWordsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBufio) ScanWordsCallCount() int {
	fake.scanWordsMutex.RLock()
	defer fake.scanWordsMutex.RUnlock()
	return len(fake.scanWordsArgsForCall)
}

func (fake *FakeBufio) ScanWordsCalls(stub func([]byte, bool) (int, []byte, error)) {
	fake.scanWordsMutex.Lock()
	defer fake.scanWordsMutex.Unlock()
	fake.ScanWordsStub = stub
}

func (fake *FakeBufio) ScanWordsArgsForCall(i int) ([]byte, bool) {
	fake.scanWordsMutex.RLock()
	defer fake.scanWordsMutex.RUnlock()
	argsForCall := fake.scanWordsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) ScanWordsReturns(result1 int, result2 []byte, result3 error) {
	fake.scanWordsMutex.Lock()
	defer fake.scanWordsMutex.Unlock()
	fake.ScanWordsStub = nil
	fake.scanWordsReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanWordsReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.scanWordsMutex.Lock()
	defer fake.scanWordsMutex.Unlock()
	fake.ScanWordsStub = nil
	if fake.scanWordsReturnsOnCall == nil {
		fake.scanWordsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.scanWordsReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newReadWriterMutex.RLock()
	defer fake.newReadWriterMutex.RUnlock()
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	fake.newReaderSizeMutex.RLock()
	defer fake.newReaderSizeMutex.RUnlock()
	fake.newScannerMutex.RLock()
	defer fake.newScannerMutex.RUnlock()
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	fake.newWriterSizeMutex.RLock()
	defer fake.newWriterSizeMutex.RUnlock()
	fake.scanBytesMutex.RLock()
	defer fake.scanBytesMutex.RUnlock()
	fake.scanLinesMutex.RLock()
	defer fake.scanLinesMutex.RUnlock()
	fake.scanRunesMutex.RLock()
	defer fake.scanRunesMutex.RUnlock()
	fake.scanWordsMutex.RLock()
	defer fake.scanWordsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBufio) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bufioshim.Bufio = new(FakeBufio)
