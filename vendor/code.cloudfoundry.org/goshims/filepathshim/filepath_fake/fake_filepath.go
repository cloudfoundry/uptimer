// Code generated by counterfeiter. DO NOT EDIT.
package filepath_fake

import (
	"path/filepath"
	"sync"

	"code.cloudfoundry.org/goshims/filepathshim"
)

type FakeFilepath struct {
	AbsStub        func(string) (string, error)
	absMutex       sync.RWMutex
	absArgsForCall []struct {
		arg1 string
	}
	absReturns struct {
		result1 string
		result2 error
	}
	absReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	BaseStub        func(string) string
	baseMutex       sync.RWMutex
	baseArgsForCall []struct {
		arg1 string
	}
	baseReturns struct {
		result1 string
	}
	baseReturnsOnCall map[int]struct {
		result1 string
	}
	CleanStub        func(string) string
	cleanMutex       sync.RWMutex
	cleanArgsForCall []struct {
		arg1 string
	}
	cleanReturns struct {
		result1 string
	}
	cleanReturnsOnCall map[int]struct {
		result1 string
	}
	DirStub        func(string) string
	dirMutex       sync.RWMutex
	dirArgsForCall []struct {
		arg1 string
	}
	dirReturns struct {
		result1 string
	}
	dirReturnsOnCall map[int]struct {
		result1 string
	}
	EvalSymlinksStub        func(string) (string, error)
	evalSymlinksMutex       sync.RWMutex
	evalSymlinksArgsForCall []struct {
		arg1 string
	}
	evalSymlinksReturns struct {
		result1 string
		result2 error
	}
	evalSymlinksReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ExtStub        func(string) string
	extMutex       sync.RWMutex
	extArgsForCall []struct {
		arg1 string
	}
	extReturns struct {
		result1 string
	}
	extReturnsOnCall map[int]struct {
		result1 string
	}
	FromSlashStub        func(string) string
	fromSlashMutex       sync.RWMutex
	fromSlashArgsForCall []struct {
		arg1 string
	}
	fromSlashReturns struct {
		result1 string
	}
	fromSlashReturnsOnCall map[int]struct {
		result1 string
	}
	GlobStub        func(string) ([]string, error)
	globMutex       sync.RWMutex
	globArgsForCall []struct {
		arg1 string
	}
	globReturns struct {
		result1 []string
		result2 error
	}
	globReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	HasPrefixStub        func(string, string) bool
	hasPrefixMutex       sync.RWMutex
	hasPrefixArgsForCall []struct {
		arg1 string
		arg2 string
	}
	hasPrefixReturns struct {
		result1 bool
	}
	hasPrefixReturnsOnCall map[int]struct {
		result1 bool
	}
	IsAbsStub        func(string) bool
	isAbsMutex       sync.RWMutex
	isAbsArgsForCall []struct {
		arg1 string
	}
	isAbsReturns struct {
		result1 bool
	}
	isAbsReturnsOnCall map[int]struct {
		result1 bool
	}
	JoinStub        func(...string) string
	joinMutex       sync.RWMutex
	joinArgsForCall []struct {
		arg1 []string
	}
	joinReturns struct {
		result1 string
	}
	joinReturnsOnCall map[int]struct {
		result1 string
	}
	MatchStub        func(string, string) (bool, error)
	matchMutex       sync.RWMutex
	matchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	matchReturns struct {
		result1 bool
		result2 error
	}
	matchReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RelStub        func(string, string) (string, error)
	relMutex       sync.RWMutex
	relArgsForCall []struct {
		arg1 string
		arg2 string
	}
	relReturns struct {
		result1 string
		result2 error
	}
	relReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SplitStub        func(string) (string, string)
	splitMutex       sync.RWMutex
	splitArgsForCall []struct {
		arg1 string
	}
	splitReturns struct {
		result1 string
		result2 string
	}
	splitReturnsOnCall map[int]struct {
		result1 string
		result2 string
	}
	SplitListStub        func(string) []string
	splitListMutex       sync.RWMutex
	splitListArgsForCall []struct {
		arg1 string
	}
	splitListReturns struct {
		result1 []string
	}
	splitListReturnsOnCall map[int]struct {
		result1 []string
	}
	ToSlashStub        func(string) string
	toSlashMutex       sync.RWMutex
	toSlashArgsForCall []struct {
		arg1 string
	}
	toSlashReturns struct {
		result1 string
	}
	toSlashReturnsOnCall map[int]struct {
		result1 string
	}
	VolumeNameStub        func(string) string
	volumeNameMutex       sync.RWMutex
	volumeNameArgsForCall []struct {
		arg1 string
	}
	volumeNameReturns struct {
		result1 string
	}
	volumeNameReturnsOnCall map[int]struct {
		result1 string
	}
	WalkStub        func(string, filepath.WalkFunc) error
	walkMutex       sync.RWMutex
	walkArgsForCall []struct {
		arg1 string
		arg2 filepath.WalkFunc
	}
	walkReturns struct {
		result1 error
	}
	walkReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFilepath) Abs(arg1 string) (string, error) {
	fake.absMutex.Lock()
	ret, specificReturn := fake.absReturnsOnCall[len(fake.absArgsForCall)]
	fake.absArgsForCall = append(fake.absArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Abs", []interface{}{arg1})
	fake.absMutex.Unlock()
	if fake.AbsStub != nil {
		return fake.AbsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.absReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) AbsCallCount() int {
	fake.absMutex.RLock()
	defer fake.absMutex.RUnlock()
	return len(fake.absArgsForCall)
}

func (fake *FakeFilepath) AbsCalls(stub func(string) (string, error)) {
	fake.absMutex.Lock()
	defer fake.absMutex.Unlock()
	fake.AbsStub = stub
}

func (fake *FakeFilepath) AbsArgsForCall(i int) string {
	fake.absMutex.RLock()
	defer fake.absMutex.RUnlock()
	argsForCall := fake.absArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) AbsReturns(result1 string, result2 error) {
	fake.absMutex.Lock()
	defer fake.absMutex.Unlock()
	fake.AbsStub = nil
	fake.absReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) AbsReturnsOnCall(i int, result1 string, result2 error) {
	fake.absMutex.Lock()
	defer fake.absMutex.Unlock()
	fake.AbsStub = nil
	if fake.absReturnsOnCall == nil {
		fake.absReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.absReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) Base(arg1 string) string {
	fake.baseMutex.Lock()
	ret, specificReturn := fake.baseReturnsOnCall[len(fake.baseArgsForCall)]
	fake.baseArgsForCall = append(fake.baseArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Base", []interface{}{arg1})
	fake.baseMutex.Unlock()
	if fake.BaseStub != nil {
		return fake.BaseStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.baseReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) BaseCallCount() int {
	fake.baseMutex.RLock()
	defer fake.baseMutex.RUnlock()
	return len(fake.baseArgsForCall)
}

func (fake *FakeFilepath) BaseCalls(stub func(string) string) {
	fake.baseMutex.Lock()
	defer fake.baseMutex.Unlock()
	fake.BaseStub = stub
}

func (fake *FakeFilepath) BaseArgsForCall(i int) string {
	fake.baseMutex.RLock()
	defer fake.baseMutex.RUnlock()
	argsForCall := fake.baseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) BaseReturns(result1 string) {
	fake.baseMutex.Lock()
	defer fake.baseMutex.Unlock()
	fake.BaseStub = nil
	fake.baseReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) BaseReturnsOnCall(i int, result1 string) {
	fake.baseMutex.Lock()
	defer fake.baseMutex.Unlock()
	fake.BaseStub = nil
	if fake.baseReturnsOnCall == nil {
		fake.baseReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.baseReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Clean(arg1 string) string {
	fake.cleanMutex.Lock()
	ret, specificReturn := fake.cleanReturnsOnCall[len(fake.cleanArgsForCall)]
	fake.cleanArgsForCall = append(fake.cleanArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Clean", []interface{}{arg1})
	fake.cleanMutex.Unlock()
	if fake.CleanStub != nil {
		return fake.CleanStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cleanReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) CleanCallCount() int {
	fake.cleanMutex.RLock()
	defer fake.cleanMutex.RUnlock()
	return len(fake.cleanArgsForCall)
}

func (fake *FakeFilepath) CleanCalls(stub func(string) string) {
	fake.cleanMutex.Lock()
	defer fake.cleanMutex.Unlock()
	fake.CleanStub = stub
}

func (fake *FakeFilepath) CleanArgsForCall(i int) string {
	fake.cleanMutex.RLock()
	defer fake.cleanMutex.RUnlock()
	argsForCall := fake.cleanArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) CleanReturns(result1 string) {
	fake.cleanMutex.Lock()
	defer fake.cleanMutex.Unlock()
	fake.CleanStub = nil
	fake.cleanReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) CleanReturnsOnCall(i int, result1 string) {
	fake.cleanMutex.Lock()
	defer fake.cleanMutex.Unlock()
	fake.CleanStub = nil
	if fake.cleanReturnsOnCall == nil {
		fake.cleanReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cleanReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Dir(arg1 string) string {
	fake.dirMutex.Lock()
	ret, specificReturn := fake.dirReturnsOnCall[len(fake.dirArgsForCall)]
	fake.dirArgsForCall = append(fake.dirArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Dir", []interface{}{arg1})
	fake.dirMutex.Unlock()
	if fake.DirStub != nil {
		return fake.DirStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dirReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) DirCallCount() int {
	fake.dirMutex.RLock()
	defer fake.dirMutex.RUnlock()
	return len(fake.dirArgsForCall)
}

func (fake *FakeFilepath) DirCalls(stub func(string) string) {
	fake.dirMutex.Lock()
	defer fake.dirMutex.Unlock()
	fake.DirStub = stub
}

func (fake *FakeFilepath) DirArgsForCall(i int) string {
	fake.dirMutex.RLock()
	defer fake.dirMutex.RUnlock()
	argsForCall := fake.dirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) DirReturns(result1 string) {
	fake.dirMutex.Lock()
	defer fake.dirMutex.Unlock()
	fake.DirStub = nil
	fake.dirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) DirReturnsOnCall(i int, result1 string) {
	fake.dirMutex.Lock()
	defer fake.dirMutex.Unlock()
	fake.DirStub = nil
	if fake.dirReturnsOnCall == nil {
		fake.dirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.dirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) EvalSymlinks(arg1 string) (string, error) {
	fake.evalSymlinksMutex.Lock()
	ret, specificReturn := fake.evalSymlinksReturnsOnCall[len(fake.evalSymlinksArgsForCall)]
	fake.evalSymlinksArgsForCall = append(fake.evalSymlinksArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("EvalSymlinks", []interface{}{arg1})
	fake.evalSymlinksMutex.Unlock()
	if fake.EvalSymlinksStub != nil {
		return fake.EvalSymlinksStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.evalSymlinksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) EvalSymlinksCallCount() int {
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	return len(fake.evalSymlinksArgsForCall)
}

func (fake *FakeFilepath) EvalSymlinksCalls(stub func(string) (string, error)) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = stub
}

func (fake *FakeFilepath) EvalSymlinksArgsForCall(i int) string {
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	argsForCall := fake.evalSymlinksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) EvalSymlinksReturns(result1 string, result2 error) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = nil
	fake.evalSymlinksReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) EvalSymlinksReturnsOnCall(i int, result1 string, result2 error) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = nil
	if fake.evalSymlinksReturnsOnCall == nil {
		fake.evalSymlinksReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.evalSymlinksReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) Ext(arg1 string) string {
	fake.extMutex.Lock()
	ret, specificReturn := fake.extReturnsOnCall[len(fake.extArgsForCall)]
	fake.extArgsForCall = append(fake.extArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Ext", []interface{}{arg1})
	fake.extMutex.Unlock()
	if fake.ExtStub != nil {
		return fake.ExtStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.extReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) ExtCallCount() int {
	fake.extMutex.RLock()
	defer fake.extMutex.RUnlock()
	return len(fake.extArgsForCall)
}

func (fake *FakeFilepath) ExtCalls(stub func(string) string) {
	fake.extMutex.Lock()
	defer fake.extMutex.Unlock()
	fake.ExtStub = stub
}

func (fake *FakeFilepath) ExtArgsForCall(i int) string {
	fake.extMutex.RLock()
	defer fake.extMutex.RUnlock()
	argsForCall := fake.extArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) ExtReturns(result1 string) {
	fake.extMutex.Lock()
	defer fake.extMutex.Unlock()
	fake.ExtStub = nil
	fake.extReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) ExtReturnsOnCall(i int, result1 string) {
	fake.extMutex.Lock()
	defer fake.extMutex.Unlock()
	fake.ExtStub = nil
	if fake.extReturnsOnCall == nil {
		fake.extReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.extReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) FromSlash(arg1 string) string {
	fake.fromSlashMutex.Lock()
	ret, specificReturn := fake.fromSlashReturnsOnCall[len(fake.fromSlashArgsForCall)]
	fake.fromSlashArgsForCall = append(fake.fromSlashArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FromSlash", []interface{}{arg1})
	fake.fromSlashMutex.Unlock()
	if fake.FromSlashStub != nil {
		return fake.FromSlashStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fromSlashReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) FromSlashCallCount() int {
	fake.fromSlashMutex.RLock()
	defer fake.fromSlashMutex.RUnlock()
	return len(fake.fromSlashArgsForCall)
}

func (fake *FakeFilepath) FromSlashCalls(stub func(string) string) {
	fake.fromSlashMutex.Lock()
	defer fake.fromSlashMutex.Unlock()
	fake.FromSlashStub = stub
}

func (fake *FakeFilepath) FromSlashArgsForCall(i int) string {
	fake.fromSlashMutex.RLock()
	defer fake.fromSlashMutex.RUnlock()
	argsForCall := fake.fromSlashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) FromSlashReturns(result1 string) {
	fake.fromSlashMutex.Lock()
	defer fake.fromSlashMutex.Unlock()
	fake.FromSlashStub = nil
	fake.fromSlashReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) FromSlashReturnsOnCall(i int, result1 string) {
	fake.fromSlashMutex.Lock()
	defer fake.fromSlashMutex.Unlock()
	fake.FromSlashStub = nil
	if fake.fromSlashReturnsOnCall == nil {
		fake.fromSlashReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.fromSlashReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Glob(arg1 string) ([]string, error) {
	fake.globMutex.Lock()
	ret, specificReturn := fake.globReturnsOnCall[len(fake.globArgsForCall)]
	fake.globArgsForCall = append(fake.globArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Glob", []interface{}{arg1})
	fake.globMutex.Unlock()
	if fake.GlobStub != nil {
		return fake.GlobStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.globReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) GlobCallCount() int {
	fake.globMutex.RLock()
	defer fake.globMutex.RUnlock()
	return len(fake.globArgsForCall)
}

func (fake *FakeFilepath) GlobCalls(stub func(string) ([]string, error)) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = stub
}

func (fake *FakeFilepath) GlobArgsForCall(i int) string {
	fake.globMutex.RLock()
	defer fake.globMutex.RUnlock()
	argsForCall := fake.globArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) GlobReturns(result1 []string, result2 error) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = nil
	fake.globReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) GlobReturnsOnCall(i int, result1 []string, result2 error) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = nil
	if fake.globReturnsOnCall == nil {
		fake.globReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.globReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) HasPrefix(arg1 string, arg2 string) bool {
	fake.hasPrefixMutex.Lock()
	ret, specificReturn := fake.hasPrefixReturnsOnCall[len(fake.hasPrefixArgsForCall)]
	fake.hasPrefixArgsForCall = append(fake.hasPrefixArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("HasPrefix", []interface{}{arg1, arg2})
	fake.hasPrefixMutex.Unlock()
	if fake.HasPrefixStub != nil {
		return fake.HasPrefixStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasPrefixReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) HasPrefixCallCount() int {
	fake.hasPrefixMutex.RLock()
	defer fake.hasPrefixMutex.RUnlock()
	return len(fake.hasPrefixArgsForCall)
}

func (fake *FakeFilepath) HasPrefixCalls(stub func(string, string) bool) {
	fake.hasPrefixMutex.Lock()
	defer fake.hasPrefixMutex.Unlock()
	fake.HasPrefixStub = stub
}

func (fake *FakeFilepath) HasPrefixArgsForCall(i int) (string, string) {
	fake.hasPrefixMutex.RLock()
	defer fake.hasPrefixMutex.RUnlock()
	argsForCall := fake.hasPrefixArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFilepath) HasPrefixReturns(result1 bool) {
	fake.hasPrefixMutex.Lock()
	defer fake.hasPrefixMutex.Unlock()
	fake.HasPrefixStub = nil
	fake.hasPrefixReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFilepath) HasPrefixReturnsOnCall(i int, result1 bool) {
	fake.hasPrefixMutex.Lock()
	defer fake.hasPrefixMutex.Unlock()
	fake.HasPrefixStub = nil
	if fake.hasPrefixReturnsOnCall == nil {
		fake.hasPrefixReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasPrefixReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFilepath) IsAbs(arg1 string) bool {
	fake.isAbsMutex.Lock()
	ret, specificReturn := fake.isAbsReturnsOnCall[len(fake.isAbsArgsForCall)]
	fake.isAbsArgsForCall = append(fake.isAbsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IsAbs", []interface{}{arg1})
	fake.isAbsMutex.Unlock()
	if fake.IsAbsStub != nil {
		return fake.IsAbsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isAbsReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) IsAbsCallCount() int {
	fake.isAbsMutex.RLock()
	defer fake.isAbsMutex.RUnlock()
	return len(fake.isAbsArgsForCall)
}

func (fake *FakeFilepath) IsAbsCalls(stub func(string) bool) {
	fake.isAbsMutex.Lock()
	defer fake.isAbsMutex.Unlock()
	fake.IsAbsStub = stub
}

func (fake *FakeFilepath) IsAbsArgsForCall(i int) string {
	fake.isAbsMutex.RLock()
	defer fake.isAbsMutex.RUnlock()
	argsForCall := fake.isAbsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) IsAbsReturns(result1 bool) {
	fake.isAbsMutex.Lock()
	defer fake.isAbsMutex.Unlock()
	fake.IsAbsStub = nil
	fake.isAbsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFilepath) IsAbsReturnsOnCall(i int, result1 bool) {
	fake.isAbsMutex.Lock()
	defer fake.isAbsMutex.Unlock()
	fake.IsAbsStub = nil
	if fake.isAbsReturnsOnCall == nil {
		fake.isAbsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAbsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFilepath) Join(arg1 ...string) string {
	fake.joinMutex.Lock()
	ret, specificReturn := fake.joinReturnsOnCall[len(fake.joinArgsForCall)]
	fake.joinArgsForCall = append(fake.joinArgsForCall, struct {
		arg1 []string
	}{arg1})
	fake.recordInvocation("Join", []interface{}{arg1})
	fake.joinMutex.Unlock()
	if fake.JoinStub != nil {
		return fake.JoinStub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.joinReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) JoinCallCount() int {
	fake.joinMutex.RLock()
	defer fake.joinMutex.RUnlock()
	return len(fake.joinArgsForCall)
}

func (fake *FakeFilepath) JoinCalls(stub func(...string) string) {
	fake.joinMutex.Lock()
	defer fake.joinMutex.Unlock()
	fake.JoinStub = stub
}

func (fake *FakeFilepath) JoinArgsForCall(i int) []string {
	fake.joinMutex.RLock()
	defer fake.joinMutex.RUnlock()
	argsForCall := fake.joinArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) JoinReturns(result1 string) {
	fake.joinMutex.Lock()
	defer fake.joinMutex.Unlock()
	fake.JoinStub = nil
	fake.joinReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) JoinReturnsOnCall(i int, result1 string) {
	fake.joinMutex.Lock()
	defer fake.joinMutex.Unlock()
	fake.JoinStub = nil
	if fake.joinReturnsOnCall == nil {
		fake.joinReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.joinReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Match(arg1 string, arg2 string) (bool, error) {
	fake.matchMutex.Lock()
	ret, specificReturn := fake.matchReturnsOnCall[len(fake.matchArgsForCall)]
	fake.matchArgsForCall = append(fake.matchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Match", []interface{}{arg1, arg2})
	fake.matchMutex.Unlock()
	if fake.MatchStub != nil {
		return fake.MatchStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.matchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) MatchCallCount() int {
	fake.matchMutex.RLock()
	defer fake.matchMutex.RUnlock()
	return len(fake.matchArgsForCall)
}

func (fake *FakeFilepath) MatchCalls(stub func(string, string) (bool, error)) {
	fake.matchMutex.Lock()
	defer fake.matchMutex.Unlock()
	fake.MatchStub = stub
}

func (fake *FakeFilepath) MatchArgsForCall(i int) (string, string) {
	fake.matchMutex.RLock()
	defer fake.matchMutex.RUnlock()
	argsForCall := fake.matchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFilepath) MatchReturns(result1 bool, result2 error) {
	fake.matchMutex.Lock()
	defer fake.matchMutex.Unlock()
	fake.MatchStub = nil
	fake.matchReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) MatchReturnsOnCall(i int, result1 bool, result2 error) {
	fake.matchMutex.Lock()
	defer fake.matchMutex.Unlock()
	fake.MatchStub = nil
	if fake.matchReturnsOnCall == nil {
		fake.matchReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.matchReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) Rel(arg1 string, arg2 string) (string, error) {
	fake.relMutex.Lock()
	ret, specificReturn := fake.relReturnsOnCall[len(fake.relArgsForCall)]
	fake.relArgsForCall = append(fake.relArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Rel", []interface{}{arg1, arg2})
	fake.relMutex.Unlock()
	if fake.RelStub != nil {
		return fake.RelStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.relReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) RelCallCount() int {
	fake.relMutex.RLock()
	defer fake.relMutex.RUnlock()
	return len(fake.relArgsForCall)
}

func (fake *FakeFilepath) RelCalls(stub func(string, string) (string, error)) {
	fake.relMutex.Lock()
	defer fake.relMutex.Unlock()
	fake.RelStub = stub
}

func (fake *FakeFilepath) RelArgsForCall(i int) (string, string) {
	fake.relMutex.RLock()
	defer fake.relMutex.RUnlock()
	argsForCall := fake.relArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFilepath) RelReturns(result1 string, result2 error) {
	fake.relMutex.Lock()
	defer fake.relMutex.Unlock()
	fake.RelStub = nil
	fake.relReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) RelReturnsOnCall(i int, result1 string, result2 error) {
	fake.relMutex.Lock()
	defer fake.relMutex.Unlock()
	fake.RelStub = nil
	if fake.relReturnsOnCall == nil {
		fake.relReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.relReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) Split(arg1 string) (string, string) {
	fake.splitMutex.Lock()
	ret, specificReturn := fake.splitReturnsOnCall[len(fake.splitArgsForCall)]
	fake.splitArgsForCall = append(fake.splitArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Split", []interface{}{arg1})
	fake.splitMutex.Unlock()
	if fake.SplitStub != nil {
		return fake.SplitStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.splitReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) SplitCallCount() int {
	fake.splitMutex.RLock()
	defer fake.splitMutex.RUnlock()
	return len(fake.splitArgsForCall)
}

func (fake *FakeFilepath) SplitCalls(stub func(string) (string, string)) {
	fake.splitMutex.Lock()
	defer fake.splitMutex.Unlock()
	fake.SplitStub = stub
}

func (fake *FakeFilepath) SplitArgsForCall(i int) string {
	fake.splitMutex.RLock()
	defer fake.splitMutex.RUnlock()
	argsForCall := fake.splitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) SplitReturns(result1 string, result2 string) {
	fake.splitMutex.Lock()
	defer fake.splitMutex.Unlock()
	fake.SplitStub = nil
	fake.splitReturns = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeFilepath) SplitReturnsOnCall(i int, result1 string, result2 string) {
	fake.splitMutex.Lock()
	defer fake.splitMutex.Unlock()
	fake.SplitStub = nil
	if fake.splitReturnsOnCall == nil {
		fake.splitReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
		})
	}
	fake.splitReturnsOnCall[i] = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeFilepath) SplitList(arg1 string) []string {
	fake.splitListMutex.Lock()
	ret, specificReturn := fake.splitListReturnsOnCall[len(fake.splitListArgsForCall)]
	fake.splitListArgsForCall = append(fake.splitListArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SplitList", []interface{}{arg1})
	fake.splitListMutex.Unlock()
	if fake.SplitListStub != nil {
		return fake.SplitListStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.splitListReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) SplitListCallCount() int {
	fake.splitListMutex.RLock()
	defer fake.splitListMutex.RUnlock()
	return len(fake.splitListArgsForCall)
}

func (fake *FakeFilepath) SplitListCalls(stub func(string) []string) {
	fake.splitListMutex.Lock()
	defer fake.splitListMutex.Unlock()
	fake.SplitListStub = stub
}

func (fake *FakeFilepath) SplitListArgsForCall(i int) string {
	fake.splitListMutex.RLock()
	defer fake.splitListMutex.RUnlock()
	argsForCall := fake.splitListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) SplitListReturns(result1 []string) {
	fake.splitListMutex.Lock()
	defer fake.splitListMutex.Unlock()
	fake.SplitListStub = nil
	fake.splitListReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeFilepath) SplitListReturnsOnCall(i int, result1 []string) {
	fake.splitListMutex.Lock()
	defer fake.splitListMutex.Unlock()
	fake.SplitListStub = nil
	if fake.splitListReturnsOnCall == nil {
		fake.splitListReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.splitListReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeFilepath) ToSlash(arg1 string) string {
	fake.toSlashMutex.Lock()
	ret, specificReturn := fake.toSlashReturnsOnCall[len(fake.toSlashArgsForCall)]
	fake.toSlashArgsForCall = append(fake.toSlashArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ToSlash", []interface{}{arg1})
	fake.toSlashMutex.Unlock()
	if fake.ToSlashStub != nil {
		return fake.ToSlashStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.toSlashReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) ToSlashCallCount() int {
	fake.toSlashMutex.RLock()
	defer fake.toSlashMutex.RUnlock()
	return len(fake.toSlashArgsForCall)
}

func (fake *FakeFilepath) ToSlashCalls(stub func(string) string) {
	fake.toSlashMutex.Lock()
	defer fake.toSlashMutex.Unlock()
	fake.ToSlashStub = stub
}

func (fake *FakeFilepath) ToSlashArgsForCall(i int) string {
	fake.toSlashMutex.RLock()
	defer fake.toSlashMutex.RUnlock()
	argsForCall := fake.toSlashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) ToSlashReturns(result1 string) {
	fake.toSlashMutex.Lock()
	defer fake.toSlashMutex.Unlock()
	fake.ToSlashStub = nil
	fake.toSlashReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) ToSlashReturnsOnCall(i int, result1 string) {
	fake.toSlashMutex.Lock()
	defer fake.toSlashMutex.Unlock()
	fake.ToSlashStub = nil
	if fake.toSlashReturnsOnCall == nil {
		fake.toSlashReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.toSlashReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) VolumeName(arg1 string) string {
	fake.volumeNameMutex.Lock()
	ret, specificReturn := fake.volumeNameReturnsOnCall[len(fake.volumeNameArgsForCall)]
	fake.volumeNameArgsForCall = append(fake.volumeNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("VolumeName", []interface{}{arg1})
	fake.volumeNameMutex.Unlock()
	if fake.VolumeNameStub != nil {
		return fake.VolumeNameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.volumeNameReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) VolumeNameCallCount() int {
	fake.volumeNameMutex.RLock()
	defer fake.volumeNameMutex.RUnlock()
	return len(fake.volumeNameArgsForCall)
}

func (fake *FakeFilepath) VolumeNameCalls(stub func(string) string) {
	fake.volumeNameMutex.Lock()
	defer fake.volumeNameMutex.Unlock()
	fake.VolumeNameStub = stub
}

func (fake *FakeFilepath) VolumeNameArgsForCall(i int) string {
	fake.volumeNameMutex.RLock()
	defer fake.volumeNameMutex.RUnlock()
	argsForCall := fake.volumeNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) VolumeNameReturns(result1 string) {
	fake.volumeNameMutex.Lock()
	defer fake.volumeNameMutex.Unlock()
	fake.VolumeNameStub = nil
	fake.volumeNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) VolumeNameReturnsOnCall(i int, result1 string) {
	fake.volumeNameMutex.Lock()
	defer fake.volumeNameMutex.Unlock()
	fake.VolumeNameStub = nil
	if fake.volumeNameReturnsOnCall == nil {
		fake.volumeNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.volumeNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Walk(arg1 string, arg2 filepath.WalkFunc) error {
	fake.walkMutex.Lock()
	ret, specificReturn := fake.walkReturnsOnCall[len(fake.walkArgsForCall)]
	fake.walkArgsForCall = append(fake.walkArgsForCall, struct {
		arg1 string
		arg2 filepath.WalkFunc
	}{arg1, arg2})
	fake.recordInvocation("Walk", []interface{}{arg1, arg2})
	fake.walkMutex.Unlock()
	if fake.WalkStub != nil {
		return fake.WalkStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.walkReturns
	return fakeReturns.result1
}

func (fake *FakeFilepath) WalkCallCount() int {
	fake.walkMutex.RLock()
	defer fake.walkMutex.RUnlock()
	return len(fake.walkArgsForCall)
}

func (fake *FakeFilepath) WalkCalls(stub func(string, filepath.WalkFunc) error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = stub
}

func (fake *FakeFilepath) WalkArgsForCall(i int) (string, filepath.WalkFunc) {
	fake.walkMutex.RLock()
	defer fake.walkMutex.RUnlock()
	argsForCall := fake.walkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFilepath) WalkReturns(result1 error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = nil
	fake.walkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFilepath) WalkReturnsOnCall(i int, result1 error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = nil
	if fake.walkReturnsOnCall == nil {
		fake.walkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.walkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFilepath) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.absMutex.RLock()
	defer fake.absMutex.RUnlock()
	fake.baseMutex.RLock()
	defer fake.baseMutex.RUnlock()
	fake.cleanMutex.RLock()
	defer fake.cleanMutex.RUnlock()
	fake.dirMutex.RLock()
	defer fake.dirMutex.RUnlock()
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	fake.extMutex.RLock()
	defer fake.extMutex.RUnlock()
	fake.fromSlashMutex.RLock()
	defer fake.fromSlashMutex.RUnlock()
	fake.globMutex.RLock()
	defer fake.globMutex.RUnlock()
	fake.hasPrefixMutex.RLock()
	defer fake.hasPrefixMutex.RUnlock()
	fake.isAbsMutex.RLock()
	defer fake.isAbsMutex.RUnlock()
	fake.joinMutex.RLock()
	defer fake.joinMutex.RUnlock()
	fake.matchMutex.RLock()
	defer fake.matchMutex.RUnlock()
	fake.relMutex.RLock()
	defer fake.relMutex.RUnlock()
	fake.splitMutex.RLock()
	defer fake.splitMutex.RUnlock()
	fake.splitListMutex.RLock()
	defer fake.splitListMutex.RUnlock()
	fake.toSlashMutex.RLock()
	defer fake.toSlashMutex.RUnlock()
	fake.volumeNameMutex.RLock()
	defer fake.volumeNameMutex.RUnlock()
	fake.walkMutex.RLock()
	defer fake.walkMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFilepath) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ filepathshim.Filepath = new(FakeFilepath)
